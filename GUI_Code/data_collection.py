'''
Old way of saving data
========================
Data processing
This is how it is written in the file:

 1. Header (Text) - 500 B
 2. Data (Binary) - N bytes

Data format would be

* Config - 72 B
* DATA samples - N Records of X Bytes
* Config
* DATA samples - N Records of X Bytes

HEADER
-------
* DATA_HEADER_SIZE = 500B
* Data is stored in plain text
* Data in the data file: subject_id: <>,date: <>,time: <>,configuration_file: <>,

CONFIGURATION
--------------
* DATA_CONFIGURATION_SIZE = 76
* Config Data is stored in a specified format and that is
  DATA_CONFIG_FORMAT = <iffffffiifffhhhhhhhhiii
* What data:

    no of records - (int 4B)
    fixation window acquire time - (float- 4B)
    fixation window hold time - ( float - 4B)
    target window hold time - (float - 4b)
    inter trial stimulus interval - ((float - 4B)
    inter stimulus interval - ((float - 4B)
    missed trial interval - (float - 4B)
    response hold time - (int - 4B)
    stimulus duration time - (int - 4B)
    fixation window size - (float - 4B)
    target window size - (float - 4B)
    vergence size - (float - 4B)
    X Left eye offset - (short - 2B)
    X Left eye gain - (short - 2B)
    Y Left eye offset - (short - 2B)
    Y Left eye gain - (short - 2B)
    X Right eye offset - (short - 2B)
    X Right eye gain - (short - 2B)
    Y Right eye offset - (short - 2B)
    Y Right eye gain - (short - 2B)
    Left pupil size - (int - 4B)
    Right pupil size - (int - 4B)
    Eye Coil channel selection in int - (int 4B)


DATA:
------
* DATA_SIZE = 96
* DATA_MATLAB_SIZE = 64
* DATA_FORMAT = '<diiiiii{}s'.format(DATA_MATLAB_SIZE)
* What Data:
    Timestamp generated by UI - (double 8B)
    right eye X - (int - 4B)
    right eye Y - (int - 4B)
    right eye Z - (int - 4B)
    left eye X - (int - 4B)
    left eye Y - (int - 4B)
    left eye Z - (int - 4B)
    Matlab data - (str - 64B)


New way of saving data
=========================

Data processing
This is how it is written in the file:

 1. Header (Text) - 500 B
 2. Data (Binary) - N bytes

    Data format would be
    --------------------
    * Configuration - 44 B
    * DATA samples - N Records of Y Bytes
    * Configuration - 44 B
    * DATA samples - N Records of Y Bytes

HEADER
-------
* DATA_HEADER_SIZE = 500B
* Data is stored in plain text
* Data in the data file: subject_id: <>,date: <>,time: <>,configuration_file: <>,

CONFIGURATION
--------------
* DATA_CONFIGURATION_SIZE = 44
* Config Data is stored in a specified format and that is
  DATA_CONFIG_FORMAT = <iffffffff
* What data:

    no of records - (int 4B)
    X Left eye offset - (float - 4B)
    X Left eye gain - (float - 4B)
    Y Left eye offset - (float - 4B)
    Y Left eye gain - (float - 4B)
    X Right eye offset - (float - 4B)
    X Right eye gain - (float - 4B)
    Y Right eye offset - (float - 4B)
    Y Right eye gain - (float - 4B)

DATA:
------
* DATA_SIZE = 96
* DATA_MATLAB_SIZE = 64
* DATA_FORMAT = '<diiii{}s'.format(DATA_MATLAB_SIZE)
* What Data:
    Timestamp generated by UI - (double 8B)
    Left eye X - (int - 4B)
    Left eye Y - (int - 4B)
    Right eye X - (int - 4B)
    Right eye Y - (int - 4B)
    3rd party data - (str - 72B)
'''

import os
import sys
import time
import struct
from constants import Constant as const, EyeRecordingMethods, ConfigLabels
import utility as util
from global_parameters import Globals as globls
from logger import logging


DATA_HEADER_SIZE = 500  # Bytes
DATA_CONFIG_FORMAT = '<iffffffff'
DATA_CONFIGURATION_SIZE = struct.calcsize(DATA_CONFIG_FORMAT)

DATA_TIMESTAMP_SIZE = 8
DATA_MATLAB_SIZE = 72  # Bytes
DATA_FORMAT = '<dffff{}s'.format(DATA_MATLAB_SIZE)
DATA_SIZE = struct.calcsize(DATA_FORMAT)
# I have put this here but generally should be in config as this is going
# to be configured by the user
RAW_EYE_TASK_DATA_LIMIT = 200

log = logging.getLogger(__name__)

class DataCollection:
    def __init__(self):
        self.data_collect_flag = False
        self.data_file = None
        self.total_records = 0

    def is_data_file_created(self):
        '''
        Data file created
        :return:
        '''
        return True if self.data_file else False

    # data collect flag ON=True OFF=False
    def update_data_collect_flag(self, on_off=True):
        '''
        Update this flag when data file is to be collected and stopped
        :param on_off:
        :return:
        '''
        self.data_collect_flag = on_off

    def reset_file_name(self):
        if self.data_collect_flag:
            return False
        self.data_file = None
        self.total_records = 0
        return True

    def update_file_name(self, name):
        '''
        Update with new data file
        :param name:
        :return:
        '''
        file_name = name + '_{}'.format(time.strftime("%m_%d_%y_%H_%M_%S"))
        data_directory = os.path.join(const.CUR_DIR_NAME, globls.directories['data'])
        if not os.path.exists(data_directory):
            os.makedirs(data_directory)

        self.data_file = os.path.join(data_directory, file_name)
        self.total_records = 0

    def write_header_data(self, header):
        '''
        Data header
        :param header:
        :return:
        '''
        with open(self.data_file, "wb") as file:
            file.seek(0, 0)
            file.write(header)
            self.data_header_written = True

    def update_header_into_data_file(self):
        '''
         create and save the header data
        '''
        header_text = 'Subject Id: {},'.format(
            globls.subject_name
        )
        header_text += 'date: {},'.format(time.strftime("%d_%m_%y"))
        header_text += 'time: {},'.format(time.strftime("%H_%M_%S"))

        eye_recording_method = globls.eye_recording_method
        if eye_recording_method == EyeRecordingMethods.EYE_COIL:
            header_text += 'Eye Recording Method: EyeCoil'
            header_text += 'Channels Selected: {},'.format(
                globls.eye_recording_method_obj.get_channel_selected_list()
            )
            eye_pos_rec_in_channel = globls.eye_recording_method_obj.get_eye_positions_channel()
            header_text += 'Channels Selected for eye pos recording: {},'.format(
                globls.eye_recording_method_obj.get_channel_selected_list()
            )
        else:
            header_text += 'Eye Recording Method: EyeLink'
        padded_header_text = util.data_padder(header_text, 500, ' ')
        self.write_header_data(padded_header_text)

    def read_header_in_data_file(self, file):
        '''
        Read the data header
        :param file:
        :return:
        '''
        with open(file, 'rb+') as file:
            file.seek(0, 0)
            data = file.read(500)
            return data

    def write_data(self, config_data, rec_data):
        '''
        Write data to the header as binary
        :param config_data:
        :param rec_data:
        :return:
        '''
        if not self.data_file:
            print self.data_file, "Could not write data"
            return False

        # Write the data
        with open(self.data_file, 'ab+') as f:
            # Write the config
            f.write(struct.pack(DATA_CONFIG_FORMAT, *config_data))

            # Write data
            for rec in rec_data:
                f.write(struct.pack(DATA_FORMAT, *rec))

    def read_records(self, f):
        '''
        Read records from the data file
        :param f:
        :return:
        '''
        # Read the config
        config_raw = f.read(DATA_CONFIGURATION_SIZE)
        if not config_raw:
            return False, None, None

        config = struct.unpack(DATA_CONFIG_FORMAT, config_raw)

        data_between_task = []
        for c in range(config[0]):  # config[0]  has the total data written for a task
            d = struct.unpack(DATA_FORMAT, f.read(DATA_SIZE))
            data_between_task.append(d)

        return True, data_between_task, config

        # Sample code to read the data file

    def read_data(self, file_name):
        '''
        Read the data from data file
        :param file_name:
        :return:
        '''
        with open(file_name, 'rb+') as f:
            # Advance by header size
            f.seek(DATA_HEADER_SIZE)
            total_data = 0
            complete_data = []
            while True:

                status, data, config = self.read_records(f)
                if not status:
                    return complete_data

                total_data += len(data)
                complete_data.append({'config': config, 'data': data})

        return None

    def dump_data_to_file(self):
        '''
        Dump data to file
        :return:
        '''
        # Set the flag not to collect data
        self.update_data_collect_flag(False)

        tempCache = globls.raw_eye_task_data
        globls.update_raw_eye_task_data([])


        # Dump configuration data, actual data from eyelink or 3rd party server
        config = []
        config.append(len(tempCache))
        config.append(globls.offset_gain_config['left_offset_x'])
        config.append(globls.offset_gain_config['left_gain_x'])
        config.append(globls.offset_gain_config['left_offset_y'])
        config.append(globls.offset_gain_config['left_gain_y'])
        config.append(globls.offset_gain_config['right_offset_x'])
        config.append(globls.offset_gain_config['right_gain_x'])
        config.append(globls.offset_gain_config['right_offset_y'])
        config.append(globls.offset_gain_config['right_gain_y'])


        self.write_data(config, tempCache)

        #Keep track of total data written
        self.total_records += len(tempCache)
        # Clean up all the global data variables


    def save_raw_eye_taskdata(self, ts, left_eye_x=0, left_eye_y=0, right_eye_x=0, right_eye_y=0, task_data=None):
        '''
        Save eye data to a list to be later written to a file
        :param ts:
        :param left_eye_x:
        :param left_eye_y:
        :param right_eye_x:
        :param right_eye_y:
        :param pupil_size_left:
        :param pupil_size_right:
        :return:
        '''
        if self.data_collect_flag:
            # Save timestamp, leftx, lefty, pupilsize, rightx, righty, pupil size, task data
            # task data is Null as there is no task data when eye data is collected
            data = [ts, left_eye_x, left_eye_y, right_eye_x, right_eye_y, '' if task_data is None else task_data]
            globls.update_raw_eye_task_data(data)

    '''
            update based on the data size reaching a limit
    '''

    '''
        Return true if the data size has exceeded the specified limit.
    '''

    def raw_eye_task_data_limit_reached(self):
        # 2 Options - Check by list length or list size
        data_size = len(globls.raw_eye_task_data)
        return data_size >= RAW_EYE_TASK_DATA_LIMIT

    '''
        Dump data to file capped by size
        :return:
    '''

    def dump_data_to_file_cap_by_size(self, ):

        if not self.raw_eye_task_data_limit_reached():
            return

        tempCache = globls.raw_eye_task_data
        # Clean up all the global data variables
        globls.update_raw_eye_task_data([])

        # Dump configuration data, actual data from eyelink or 3rd party server
        config = []
        config.append(len(tempCache))
        print(len(tempCache))
        config.append(globls.offset_gain_config['left_offset_x'])
        config.append(globls.offset_gain_config['left_gain_x'])
        config.append(globls.offset_gain_config['left_offset_y'])
        config.append(globls.offset_gain_config['left_gain_y'])
        config.append(globls.offset_gain_config['right_offset_x'])
        config.append(globls.offset_gain_config['right_gain_x'])
        config.append(globls.offset_gain_config['right_offset_y'])
        config.append(globls.offset_gain_config['right_gain_y'])

        # Note: if there is loss of data, then it is better to deep copy raw_eye_task_data
        # into a temp file, update the globls.update_raw_eye_task_data([]) with
        # empty list
        # Then call the write_data() to write into file.
        # Update total_records based on temp file
        # Ensure to remove the last line in this method.
        self.write_data(config, tempCache)

        # Keep track of total data written
        self.total_records += len(tempCache)



    '''
        collect data - and dump data conditional based
        on size.
    '''
    def dump_data_continually(self, data_recv_ts, task_data):

        DataFileObj.save_raw_eye_taskdata(
            data_recv_ts, 0,0,0,0, task_data=task_data)

        # This can be a flag in config or can be accepted on the UI as an input.

        # Stop saving the data and dump to file
        # Flag to stop saving the data is set inside this function

        DataFileObj.dump_data_to_file_cap_by_size()

    def total_data_dumped_to_file(self):
        globls.dump_log('Total data written to file is {}'.format(self.total_records))



DataFileObj = DataCollection()


